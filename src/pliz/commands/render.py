# -*- coding: utf8 -*-
# Copyright (c) 2019 Niklas Rosenstein
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

""" CLI dispatcher for rendering files generated by plugins. """

from .base import PlizCommand
from ..core.plugins import load_plugin, construct_plugin, PluginContext, write_to_disk
from termcolor import colored
from nr.stream import Stream
import os


class RenderCommand(PlizCommand):

  name = 'render'
  description = __doc__

  def update_parser(self, parser):
    super(RenderCommand, self).update_parser(parser)
    parser.add_argument('plugin', nargs='?', help='The name of a plugin to use.')
    parser.add_argument('--recursive', action='store_true')
    parser.add_argument('--dry', action='store_true')

  def handle_unknown_args(self, parser, args, argv):
    """ Parses additional `--` flags for the plugin options. """

    if not args.plugin:
      return super(RenderCommand, self).handle_unknown_args(parser, args, argv)

    plugin_cls = load_plugin(args.plugin)
    options = plugin_cls.get_options()
    config = {}
    pos_args = []

    it = iter(argv)
    queue = []
    while True:
      item = queue.pop(0) if queue else next(it, None)
      if item is None:
        break
      if not item.startswith('--'):
        pos_args.append(item)
        continue
      if '=' in item:
        k, v = item[2:].partition('=')[::2]
      else:
        k = item[2:]
        v = next(it, 'true')
        if v.startswith('--'):
          queue.append(v)
          v = 'true'
      if v.lower().strip() in ('true', 'yes', '1', 'y', 'on', 'enabled'):
        v = True
      elif v.lower().strip() in ('false', 'no', '0', 'n', 'off', 'disabled'):
        v = False
      else:
        for f in (float, int):
          try:
            v = f(v)
          except ValueError:
            pass
      config[k] = v

    if len(pos_args) > len(options):
      parser.error('expected at max {} positional arguments, got {}'.format(
        len(plugin_cls.options), len(pos_args)))
    for option, value in zip(options, pos_args):
      if option.name in config:
        parser.error('duplicate argument value for option "{}"'.format(option.name))
      config[option.name] = value

    base_config = {o.name: o.get_default() for o in options if not o.required}
    base_config.update(config)
    config = base_config

    # TODO (@NiklasRosenstein): If custom options are defined for this
    #   plugin in the monorepo or package, we probably want to inherit
    #   the settings and only override what is defined as CLI options.
    #   That will require us to move the construction of the plugin
    #   instance to execute() and create one instance per monorepo/package.
    args._plugin = construct_plugin(plugin_cls, config)

  def execute(self, parser, args):
    super(RenderCommand, self).execute(parser, args)

    if not args.plugin:
      args.recursive = True

    monorepo, package = self.get_configuration()
    if package:
      context = PluginContext(None, [package])
    else:
      packages = monorepo.list_packages() if args.recursive else []
      context = PluginContext(monorepo, packages)

    files = []
    checks = []
    if args.plugin:
      files.extend(args._plugin.get_files_to_render(context))
      checks.extend(args._plugin.perform_checks(context))
    else:
      for plugin, ctx in context.iter_plugin_ctx_combinations():
        files.extend(plugin.get_files_to_render(ctx))
        checks.extend(plugin.perform_checks(ctx))

    if checks:
      for element, checks in Stream(checks).groupby(lambda x: x.on):
        for check in checks:
          color = {'ERROR': 'red', 'WARNING': 'magenta', 'INFO': None}
          color = color[check.level.name]
          print('{}:{}: {}'.format(element.name,
            colored(check.level.name, color), check.message))

    print('Rendering {} file(s)'.format(len(files)))
    for file in files:
      print(' ', file.name)
      if not args.dry:
        write_to_disk(file)
